# tradingagents/models/types.py
from __future__ import annotations

from datetime import date, datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Field, field_validator


# ------------------------------------------------------------
# ENUMS
# ------------------------------------------------------------

class ResearchDepth(str, Enum):
    """Defines how exhaustive the analysis should be."""
    quick = "quick"      # minimal cost, light summaries
    normal = "normal"    # balanced depth vs. speed
    deep = "deep"        # full reasoning, higher token cost


class AnalystTopic(str, Enum):
    """Categories of analytical expertise."""
    fundamentals = "fundamentals"
    technical = "technical"
    news = "news"
    sentiment = "sentiment"


class Stance(str, Enum):
    """Polarized research perspectives for debate."""
    bull = "bull"
    bear = "bear"


class TradeAction(str, Enum):
    """Possible portfolio actions."""
    long = "long"
    short = "short"
    hold = "hold"
    skip = "skip"


# ------------------------------------------------------------
# CORE INPUTS
# ------------------------------------------------------------

class Inputs(BaseModel):
    """
    User request describing one research or trade-decision run.

    Why:
        - Encapsulates the problem definition for reproducibility.
        - Avoids parameter sprawl in API routes or graph nodes.
    """
    ticker: str = Field(..., description="Stock or asset symbol (upper-case).")
    as_of_date: date = Field(..., description="Cut-off date for all data sources.")
    research_depth: ResearchDepth = Field(
        default=ResearchDepth.normal,
        description="Controls model selection and token budget.",
    )
    constraints: Optional[Dict[str, Union[int, float]]] = Field(
        default=None, description="Runtime cost or risk constraints."
    )
    vendor_overrides: Optional[Dict[str, str]] = Field(
        default=None, description="Override default vendor selection."
    )

    # --- Validators --------------------------------------------------------
    @field_validator("ticker")
    @classmethod
    def _upper_ticker(cls, v: str) -> str:
        """Normalize ticker casing to maintain consistent cache keys."""
        return v.upper()

    @field_validator("as_of_date")
    @classmethod
    def _not_future(cls, v: date) -> date:
        """Prevent forward-looking bias."""
        if v > date.today():
            raise ValueError("as_of_date cannot be in the future.")
        return v


# ------------------------------------------------------------
# RAW DATA SNAPSHOTS
# ------------------------------------------------------------

class PriceSnapshot(BaseModel):
    """
    Market data plus derived indicators.

    Notes:
        'ohlcv' can be a pandas-like dict for serialization; we avoid strict
        dependency on pandas objects to remain FastAPI-compatible.
    """
    ohlcv: Any
    indicators: Dict[str, float] = Field(default_factory=dict)
    meta: Dict[str, Any] = Field(default_factory=dict)


class FundamentalsSnapshot(BaseModel):
    """
    Company financials snapshot.
    """
    ratios: Dict[str, float]
    trend: Dict[str, float]
    notes: List[str] = Field(default_factory=list)


class NewsItem(BaseModel):
    """
    One piece of time-stamped news or media signal.
    """
    headline: str
    summary: str = Field(default="", description="Article summary or snippet")
    published_at: datetime
    source: str
    url: str
    sentiment: Optional[float] = Field(
        default=None,
        ge=-1.0,
        le=1.0,
        description="Normalized polarity; optional if vendor provides.",
    )


# ------------------------------------------------------------
# ANALYST-LEVEL OUTPUTS
# ------------------------------------------------------------

class AnalystReport(BaseModel):
    """
    Structured output of an analyst agent.
    """
    topic: AnalystTopic
    summary: str
    bullets: List[str]
    metrics: Dict[str, float] = Field(default_factory=dict)
    confidence: float = Field(..., ge=0, le=1)
    citations: List[Union[NewsItem, str]] = Field(default_factory=list)


class ResearchView(BaseModel):
    """
    Argument generated by a bull or bear researcher.
    """
    stance: Stance
    thesis: str
    evidence_for: List[str]
    evidence_against: List[str]
    confidence: float = Field(..., ge=0, le=1)


class TradePlan(BaseModel):
    """
    Candidate trading plan produced by the trader agent.

    Theory:
        - Enforces explicit risk definitions.
        - Required stop levels ensure downstream risk manager can compute
          max loss deterministically.
    """
    action: TradeAction
    entry: Optional[float] = None
    stop: Optional[float] = None
    target: Optional[float] = None
    size: Optional[float] = None
    rationale: str
    dependencies: List[str] = Field(default_factory=list)

    @field_validator("stop")
    @classmethod
    def _require_stop_for_active(cls, v, info):
        action = info.data.get("action")
        if action in {TradeAction.long, TradeAction.short} and v is None:
            raise ValueError("Active trades must specify a stop price.")
        return v