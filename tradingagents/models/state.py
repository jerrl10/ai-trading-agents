from __future__ import annotations

from typing import Dict, List, Optional, Any
from pydantic import BaseModel, Field

from .types import (
    Inputs,
    PriceSnapshot,
    FundamentalsSnapshot,
    NewsItem,
    AnalystReport,
    ResearchView,
    TradePlan,
)
from .decisions import RiskCheck, PMDecision


class GraphState(BaseModel):
    """
    Represents the evolving shared state within the agent reasoning graph.

    ---------------------------------------------------------------------
    Theory:
    ---------------------------------------------------------------------
    - In a LangGraph workflow (or any DAG-based reasoning system),
      each node (agent) is a *pure function* that takes `GraphState` as input
      and returns a new (or updated) `GraphState`.

    - By designing a single structured state:
        * We eliminate implicit dependencies between agents.
        * We can resume, audit, or replay reasoning steps.
        * It becomes trivial to persist state between async calls or sessions.

    - Conceptually, this mirrors the "blackboard" pattern used in AI systems
      where multiple specialized experts collaborate by reading/writing
      to a shared knowledge base.
    ---------------------------------------------------------------------
    """

    # ------------------------------------------------------------------
    # Core attributes
    # ------------------------------------------------------------------
    inputs: Inputs = Field(
        ..., description="Static input parameters for this reasoning session."
    )

    # ------------------------------------------------------------------
    # Data storage section
    # ------------------------------------------------------------------
    data: Dict[str, Any] = Field(
        default_factory=lambda: {
            "prices": None,          # PriceSnapshot
            "fundamentals": None,    # FundamentalsSnapshot
            "news": [],              # List[NewsItem]
        },
        description=(
            "Fetched raw data or derived datasets. Each adapter populates its section.\n"
            "The 'data' dict is flexible so new data types (e.g. sentiment, ESG, options) "
            "can be added later without schema migration."
        ),
    )

    # ------------------------------------------------------------------
    # Agent outputs
    # ------------------------------------------------------------------
    reports: Dict[str, AnalystReport] = Field(
        default_factory=dict,
        description=(
            "Outputs from analyst agents. "
            "Keys correspond to topics: 'fundamentals', 'technical', 'news', 'sentiment'."
        ),
    )

    views: Dict[str, ResearchView] = Field(
        default_factory=dict,
        description=(
            "Outputs from research agents. Keys are typically 'bull' and 'bear'. "
            "Each view contains its stance, thesis, and evidence."
        ),
    )

    candidate_plan: Optional[TradePlan] = Field(
        default=None,
        description="Provisional trade idea generated by the trader agent.",
    )

    # ------------------------------------------------------------------
    # Governance layers
    # ------------------------------------------------------------------
    risk: Optional[RiskCheck] = Field(
        default=None,
        description="Quantitative evaluation of the candidate trade plan.",
    )

    pm: Optional[PMDecision] = Field(
        default=None,
        description="Final approval decision from the portfolio manager agent.",
    )

    # ------------------------------------------------------------------
    # Diagnostics & observability
    # ------------------------------------------------------------------
    audit_log: List[str] = Field(
        default_factory=list,
        description=(
            "Chronological log of agent actions, messages, and reasoning steps. "
            "Crucial for traceability and post-mortem analysis."
        ),
    )

    costs: Dict[str, float] = Field(
        default_factory=dict,
        description=(
            "Tracking of API costs or resource usage. "
            "Keys may include 'tokens', 'usd', or per-node breakdowns."
        ),
    )

    # ------------------------------------------------------------------
    # Config section
    # ------------------------------------------------------------------
    class Config:
        """Pydantic behavior tuning."""
        extra = "allow"          # Allow new dynamic keys as the system evolves
        validate_assignment = True  # Re-run validators when values are updated
        arbitrary_types_allowed = True  # So pandas or custom types are permitted

    # ------------------------------------------------------------------
    # Utility methods
    # ------------------------------------------------------------------
    def add_audit(self, message: str) -> None:
        """
        Append a timestamped log entry.

        Why:
            - Helps visualize the reasoning path.
            - Used by both console loggers and persistent audit writers.
        """
        from datetime import datetime

        timestamp = datetime.utcnow().isoformat(timespec="seconds")
        entry = f"[{timestamp}] {message}"
        self.audit_log.append(entry)

    def summarize(self) -> str:
        """
        Return a short human-readable summary of the state.

        Useful for debugging or prompt context compression.
        """
        status_parts = [
            f"Ticker: {self.inputs.ticker}",
            f"Reports: {list(self.reports.keys()) or 'none'}",
            f"Views: {list(self.views.keys()) or 'none'}",
            f"HasPlan: {bool(self.candidate_plan)}",
            f"RiskChecked: {self.risk.ok if self.risk else 'N/A'}",
            f"Approved: {self.pm.approved if self.pm else 'N/A'}",
        ]
        return " | ".join(status_parts)